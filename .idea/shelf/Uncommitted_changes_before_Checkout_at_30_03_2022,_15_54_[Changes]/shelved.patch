Index: prepareData.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\n\nimport os, mne, time\nimport os.path\nfrom mne.io import read_raw_edf\nfrom collections import defaultdict\nfrom datetime import datetime, timezone\nimport torch, re, warnings\nimport pandas as pd\nimport numpy as np\nfrom scipy import signal, stats\nimport matplotlib.pyplot as plt\nfrom eegProcess import TUH_rename_ch, nonPipeline, spectrogramMake, slidingWindow, pipeline\nfrom braindecode.datasets import create_from_X_y\n\nclass TUH_data:\n    def __init__(self):\n        pass\n\n    def findEdf(self,path):\n        ### Makes dictionary of all edf files\n        EEG_count = 0\n        EEG_dict = {}\n\n        for dirpath, dirnames, filenames in os.walk(path):\n            for filename in [f for f in filenames if f.endswith(\".edf\")]:\n                \"\"\"For every edf file found somewhere in the directory, it is assumed the folders hold the structure: \n                \".../id/patientId/sessionId/edfFile\".\n                Therefore the path is split backwards and the EEG_dict updated with the found ids/paths.\n                Furthermore it is expected that a csv file will always be found in the directory.\"\"\"\n                session_path_split=os.path.split(dirpath)\n                patient_path_split = os.path.split(session_path_split[0])\n                id_path_split=os.path.split(patient_path_split[0])\n                EEG_dict.update({EEG_count: {\"id\": id_path_split[1], \"patient_id\": patient_path_split[1], \"session\":  session_path_split[1],\n                                          \"path\": os.path.join(dirpath, filename),\"csvpath\": os.path.join(dirpath, os.path.splitext(filename)[0]+'.csv')}})\n                EEG_count+=1\n        self.EEG_dict = EEG_dict\n        self.EEG_count=EEG_count\n\n    def loadOneRaw(self,id):\n        return mne.io.read_raw_edf(self.EEG_dict[id][\"path\"], preload=True)\n        #return self.readRawEdf().read_raw_edf(self.EEG_dict[id][\"path\"], preload=True)\n\n    def loadAllRaw(self):\n        EEG_raw_dict={}\n        for id in range(self.EEG_count):\n            EEG_raw_dict[id] = self.loadOneRaw(id)\n        self.EEG_raw_dict=EEG_raw_dict\n\n    def readRawEdf(self, edfDict=None, tWindow=120, tStep=30,\n                   read_raw_edf_param={'preload': True, \"stim_channel\": \"auto\"}):\n        #### This function i copied from https://github.com/DavidEnslevNyrnberg/DTU_DL_EEG/blob/master/Transfer%20learning%20project/eegProcess.py##\n        try:\n            edfDict[\"rawData\"] = read_raw_edf(edfDict[\"path\"], **read_raw_edf_param)\n            edfDict[\"fS\"] = edfDict[\"rawData\"].info[\"sfreq\"]\n            t_start = edfDict[\"rawData\"].annotations.orig_time\n            if t_start.timestamp() <= 0:\n                edfDict[\"t0\"] = datetime.fromtimestamp(0, tz=timezone.utc)\n                t_last = edfDict[\"t0\"].timestamp() + edfDict[\"rawData\"]._last_time + 1 / edfDict[\"fS\"]\n                edfDict[\"tN\"] = datetime.fromtimestamp(t_last, tz=timezone.utc)\n            else:\n                t_last = t_start.timestamp() + edfDict[\"rawData\"]._last_time + 1 / edfDict[\"fS\"]\n                edfDict[\"t0\"] = t_start  # datetime.fromtimestamp(t_start.timestamp(), tz=timezone.utc)\n                edfDict[\"tN\"] = datetime.fromtimestamp(t_last, tz=timezone.utc)\n\n            edfDict[\"tWindow\"] = float(tWindow)  # width of EEG sample window, given in (sec)\n            edfDict[\"tStep\"] = float(tStep)  # step/overlap between EEG sample windows, given in (sec)\n\n        except:\n            print(\"error break please inspect:\\n %s\\n~~~~~~~~~~~~\" % edfDict[\"rawData\"].filenames[0])\n\n        return edfDict\n\n    def prep(self, saveDir):\n        tic = time.time()\n        subjects_TUAR19 = defaultdict(dict)\n        Xwindows=[]\n        Ywindows=[]\n        for k in range(len(self.EEG_dict)):\n            subjects_TUAR19[k] = {'path':self.EEG_dict[k]['path']}\n\n            proc_subject = subjects_TUAR19[k]\n            proc_subject = self.readRawEdf(proc_subject, tWindow=100, tStep=100*.25,read_raw_edf_param={'preload': True})\n\n            proc_subject[\"rawData\"] = TUH_rename_ch(proc_subject[\"rawData\"])\n            TUH_pick = ['Fp1', 'Fp2', 'F3', 'F4', 'C3', 'C4', 'P3', 'P4', 'O1', 'O2',\n                        'F7', 'F8', 'T3', 'T4', 'T5', 'T6', 'Cz'] #A1, A2 removed\n            proc_subject[\"rawData\"].pick_channels(ch_names=TUH_pick)\n            proc_subject[\"rawData\"].reorder_channels(TUH_pick)\n\n            if k == 0:\n                self.sfreq = proc_subject[\"rawData\"].info[\"sfreq\"]\n                self.ch_names = proc_subject[\"rawData\"].info[\"ch_names\"]\n\n\n            pipeline(proc_subject[\"rawData\"], cap_setup=\"standard_1005\", lpfq=1, hpfq=40, notchfq=60,\n                     downSam=250)  # \"standard_1005\" \"easycap-M1\"\n\n            # Generate output windows for (X,y) as (tensor, label)\n            proc_subject[\"preprocessing_output\"] = slidingRawWindow(proc_subject, t_max=proc_subject[\"rawData\"].times[-1],\n                                                                 tStep=proc_subject[\"tStep\"], FFToverlap=0.75,\n                                                                 crop_fq=24,\n                                                                 annoDir=self.EEG_dict[k]['csvpath'],\n                                                                 localSave={\"sliceSave\": True,\n                                                                            \"saveDir\": saveDir + r'/tensor',\n                                                                            \"local_return\": False})\n\n            for window in proc_subject[\"preprocessing_output\"].values():\n                Xwindows.append(window[0])\n                Ywindows.append(window[1])\n                #Xraw=np.concatenate((Xraw,np.array([window[0]])))\n                #Y=np.concatenate((Y,np.array([window[1]])))\n\n        toc = time.time()\n        print(\"\\n~~~~~~~~~~~~~~~~~~~~\\n\"\n              \"it took %imin:%is to run preprocess-pipeline for %i patients\\n with window length [%.2fs] and t_step [%.2fs]\"\n              \"\\n~~~~~~~~~~~~~~~~~~~~\\n\"% (int((toc-tic)/60), int((toc-tic) % 60), len(subjects_TUAR19),\n                                           subjects_TUAR19[k][\"tWindow\"], subjects_TUAR19[k][\"tStep\"]))\n\n        self.Xwindows=Xwindows\n        self.Ywindows=Ywindows\n\ndef label_TUH(annoPath=False, window=[0,0], header=None): #saveDir=os.getcwd(),\n    df = pd.read_csv(annoPath, sep=\",\", skiprows=6, header=header)\n    df.fillna('null', inplace=True)\n    within_con0 = (df[2] <= window[0]) & (window[0] <= df[3])\n    within_con1 = (df[2] <= window[1]) & (window[1] <= df[3])\n    label_TUH = df[df[2].between(window[0], window[1]) |\n                   df[3].between(window[0], window[1]) |\n                   (within_con0 & within_con1)]\n    label_df = label_TUH.rename(columns={2: 't_start', 3: 't_end', 4: 'label', 5: 'confidence'})[\"label\"] #Renamer headers i pandas dataen\n    return_list = label_df.to_numpy().tolist() #Outputter kun listen af label navne i vinduet, fx [\"eyem\", \"null\"]\n    return return_list\n\ndef makeRawWindow(MNE_raw=None, t0=0, tWindow=120):\n    #take a raw signal and make a window given time specifications.\n    chWindows = MNE_raw.get_data(start=int(t0), stop=int(t0+tWindow), reject_by_annotation=\"omit\", picks=['eeg'])\n    return chWindows\n\ndef slidingRawWindow(EEG_series=None, t_max=0, tStep=1, FFToverlap=None, crop_fq=45, annoDir=None,\n                  localSave={\"sliceSave\":False, \"saveDir\":os.getcwd(), \"local_return\":False}):\n    # catch correct sample frequency and end sample\n    edf_fS = EEG_series[\"rawData\"].info[\"sfreq\"]\n    t_N = int(t_max*edf_fS)\n\n    # ensure window-overlaps progress in sample interger\n    if float(tStep*edf_fS) == float(int(tStep*edf_fS)):\n        t_overlap = int(tStep*edf_fS)\n    else:\n        t_overlap = int(tStep*edf_fS)\n        overlap_change = 100-(t_overlap/edf_fS)*100\n        print(\"\\n  tStep [%.3f], overlap does not equal an interger [%f] and have been rounded to %i\"\n              \"\\n  equaling to %.1f%% overlap or %.3fs time steps\\n\\n\"\n              % (tStep, tStep*edf_fS, t_overlap, overlap_change, t_overlap/edf_fS))\n\n    # initialize variables for segments\n    window_EEG = defaultdict(tuple)\n    window_width = int(EEG_series[\"tWindow\"]*edf_fS)\n    label_path = EEG_series['path'].split(\".edf\")[0] + \".csv\"\n\n    # segment all N-1 windows (by positive lookahead)\n    for i in range(0, t_N-window_width, t_overlap):\n        t_start = i/edf_fS\n        t_end = (i+window_width)/edf_fS\n        window_key = \"window_%.3fs_%.3fs\" % (t_start, t_end)\n        window_data = makeRawWindow(EEG_series[\"rawData\"], t0=i, tWindow=window_width) # , show_chan_num=0) #)\n        window_label = label_TUH(annoPath=label_path, window=[t_start, t_end])#, saveDir=annoDir)\n        window_EEG[window_key] = (window_data, window_label)\n    # window_N segments (by negative lookahead)\n    if t_N % t_overlap != 0:\n        t_start = (t_N - window_width)/edf_fS\n        t_end = t_N/edf_fS\n        window_key = \"window_%.3fs_%.3fs\" % (t_start, t_end)\n        window_data = makeRawWindow(EEG_series[\"rawData\"], t0=i, tWindow=window_width)\n        window_label = label_TUH(annoPath=label_path, window=[t_start, t_end])#, saveDir=annoDir)\n        window_EEG[window_key] = (window_data, window_label)\n\n    return window_EEG\n    # save in RAM, disk or not\n    \"\"\"    if localSave[\"sliceSave\"]:\n        idDir = EEG_series[\"rawData\"].filenames[0].split('\\\\')[-1].split('.')[0]\n        if not os.path.exists(localSave[\"saveDir\"] + \"tempData\\\\\"):\n            os.mkdir(localSave[\"saveDir\"] + \"tempData\\\\\")\n        if not os.path.exists(localSave[\"saveDir\"] + \"tempData\\\\\" + idDir):\n            os.mkdir(localSave[\"saveDir\"] + \"tempData\\\\\" + idDir)\n        for k, v in window_EEG.items():\n            torch.save(v, localSave[\"saveDir\"] + \"tempData\\\\%s\\\\%s.pt\" % (idDir, k)) # for np del torch.save\n    if not localSave[\"sliceSave\"] or localSave[\"local_return\"] is True:\n        windowOut = window_EEG.copy()\n    else:\n        windowOut = None\n    \n    return windowOut\"\"\"\n\npath=\"TUH_data_sample\"\nsave_dir=\"D:/fagprojekt\"\nTUH=TUH_data()\nTUH.findEdf(path=path)\nprint(TUH.EEG_dict)\nTUH.loadAllRaw()\nTUH.prep(saveDir=save_dir)\n\nwindows_dataset = create_from_X_y(\n    TUH.Xwindows, TUH.Ywindows, drop_last_window=False, sfreq=TUH.sfreq, ch_names=TUH.ch_names,\n    window_stride_samples=len(TUH.Xwindows[0][0]),\n    window_size_samples=len(TUH.Xwindows[0][0]),\n)\n\nwindows_dataset.description\n\n\n#print(TUH.EEG_raw_dict)\n#TUH.EEG_raw_dict[0].plot_psd()\n#TUH.EEG_raw_dict[0].plot(duration=4)\n#plt.show()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/prepareData.py b/prepareData.py
--- a/prepareData.py	
+++ b/prepareData.py	
@@ -208,6 +208,13 @@
 
 windows_dataset.description
 
+i = 0
+x_i, y_i, window_ind = windows_dataset[0]
+n_channels, n_times = x_i.shape  # the EEG data
+_, start_ind, stop_ind = window_ind
+print(f"n_channels={n_channels}  -- n_times={n_times} -- y_i={y_i}")
+print(f"start_ind={start_ind} -- stop_ind={stop_ind}")
+
 
 #print(TUH.EEG_raw_dict)
 #TUH.EEG_raw_dict[0].plot_psd()
