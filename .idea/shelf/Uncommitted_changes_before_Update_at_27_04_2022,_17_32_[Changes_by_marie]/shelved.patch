Index: pipeline/loadFunctions.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os, mne, time, re\nfrom mne.io import read_raw_edf\nfrom collections import defaultdict\nfrom datetime import datetime, timezone\nimport pandas as pd\nimport numpy as np\nimport torch\nfrom preprocessFunctions import simplePreprocess, rereference, preprocessRaw\nimport matplotlib.pyplot as plt\nfrom scipy import signal, stats\nfrom raw_utils import oneHotEncoder\nfrom tqdm import *\n\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\n\n##These functions are either inspired from or modified copies of code written by David Nyrnberg:\n# https://github.com/DavidEnslevNyrnberg/DTU_DL_EEG/tree/0bfd1a9349f60f44e6f7df5aa6820434e44263a2/Transfer%20learning%20project\n\n\nclass TUH_data:\n    def __init__(self, path):\n        ### Makes dictionary of all edf files\n        EEG_count = 0\n        EEG_dict = {}\n\n        for dirpath, dirnames, filenames in os.walk(path):\n            for filename in [f for f in filenames if f.endswith(\".edf\")]:\n                \"\"\"For every edf file found somewhere in the directory, it is assumed the folders hold the structure: \n                \".../id/patientId/sessionId/edfFile\".\n                Therefore the path is split backwards and the EEG_dict updated with the found ids/paths.\n                Furthermore it is expected that a csv file will always be found in the directory.\"\"\"\n                session_path_split = os.path.split(dirpath)\n                patient_path_split = os.path.split(session_path_split[0])\n                id_path_split = os.path.split(patient_path_split[0])\n                EEG_dict.update({EEG_count: {\"id\": id_path_split[1],\n                                             \"patient_id\": patient_path_split[1],\n                                             \"session\": session_path_split[1],\n                                             \"path\": os.path.join(dirpath, filename),\n                                             \"csvpath\": os.path.join(dirpath, os.path.splitext(filename)[0]+'.csv')}})\n                EEG_count += 1\n        self.EEG_dict = EEG_dict\n        self.EEG_count = EEG_count\n\n    \"\"\" These functions could probably be deleted, but are nice in case we want a quick plot of a raw file.\n    def loadOneRaw(self, id):\n        return mne.io.read_raw_edf(self.EEG_dict[id][\"path\"], preload=True)\n\n    def loadAllRaw(self):\n        EEG_raw_dict = {}\n        for id in range(self.EEG_count):\n            EEG_raw_dict[id] = self.loadOneRaw(id)\n        self.EEG_raw_dict = EEG_raw_dict\n        \"\"\"\n\n    def readRawEdf(self, edfDict=None, tWindow=120, tStep=30,\n                   read_raw_edf_param={'preload': True, \"stim_channel\": \"auto\"}):\n        try:\n            edfDict[\"rawData\"] = read_raw_edf(edfDict[\"path\"], **read_raw_edf_param)\n            edfDict[\"fS\"] = edfDict[\"rawData\"].info[\"sfreq\"]\n            t_start = edfDict[\"rawData\"].annotations.orig_time\n            if t_start.timestamp() <= 0:\n                edfDict[\"t0\"] = datetime.fromtimestamp(0, tz=timezone.utc)\n                t_last = edfDict[\"t0\"].timestamp() + edfDict[\"rawData\"]._last_time + 1 / edfDict[\"fS\"]\n                edfDict[\"tN\"] = datetime.fromtimestamp(t_last, tz=timezone.utc)\n            else:\n                t_last = t_start.timestamp() + edfDict[\"rawData\"]._last_time + 1 / edfDict[\"fS\"]\n                edfDict[\"t0\"] = t_start  # datetime.fromtimestamp(t_start.timestamp(), tz=timezone.utc)\n                edfDict[\"tN\"] = datetime.fromtimestamp(t_last, tz=timezone.utc)\n\n            edfDict[\"tWindow\"] = float(tWindow)  # width of EEG sample window, given in (sec)\n            edfDict[\"tStep\"] = float(tStep)  # step/overlap between EEG sample windows, given in (sec)\n\n        except:\n            print(\"error break please inspect:\\n %s\\n~~~~~~~~~~~~\" % edfDict[\"rawData\"].filenames[0])\n\n        return edfDict\n\n    def electrodeCLFPrep(self, tWindow=100, tStep=100 *.25,plot=False):\n        tic = time.time()\n        subjects_TUAR19 = defaultdict(dict)\n        Xwindows = []\n        Ywindows = []\n        windowInfo = []\n        for k in tqdm(range(len(self.EEG_dict))):\n            subjects_TUAR19[k] = {'path': self.EEG_dict[k]['path']}\n\n            proc_subject = subjects_TUAR19[k]\n            proc_subject = self.readRawEdf(proc_subject, tWindow=tWindow, tStep=tStep,\n                                           read_raw_edf_param={'preload': True})\n            if k == 0 and plot:\n                #Plot the energy voltage potential against frequency.\n                #proc_subject[\"rawData\"].plot_psd(tmax=np.inf, fmax=128, average=True)\n\n                raw_anno = annotate_TUH(proc_subject[\"rawData\"],annoPath=self.EEG_dict[k][\"csvpath\"])\n                raw_anno.plot()\n                plt.show()\n\n            proc_subject[\"rawData\"] = TUH_rename_ch(proc_subject[\"rawData\"])\n            TUH_pick = ['Fp1', 'Fp2', 'F3', 'F4', 'C3', 'C4', 'P3', 'P4', 'O1', 'O2',\n                        'F7', 'F8', 'T3', 'T4', 'T5', 'T6', 'Cz']  # A1, A2 removed\n            proc_subject[\"rawData\"].pick_channels(ch_names=TUH_pick)\n            proc_subject[\"rawData\"].reorder_channels(TUH_pick)\n\n            if k == 0 and plot:\n                #Plot the energy voltage potential against frequency.\n                proc_subject[\"rawData\"].plot_psd(tmax=np.inf, fmax=128, average=True)\n\n                raw_anno = annotate_TUH(proc_subject[\"rawData\"],annoPath=self.EEG_dict[k][\"csvpath\"])\n                raw_anno.plot()\n                plt.title(\"Untouched raw signal\")\n                plt.show()\n\n            simplePreprocess(proc_subject[\"rawData\"], cap_setup=\"standard_1005\", lpfq=1, hpfq=40, notchfq=60,\n                     downSam=250)\n\n            if k == 0:\n\n                self.sfreq = proc_subject[\"rawData\"].info[\"sfreq\"]\n                self.ch_names = proc_subject[\"rawData\"].info[\"ch_names\"]\n                if plot:\n                    proc_subject[\"rawData\"].plot_psd(tmax=np.inf, fmax=125, average=True)\n\n                    raw_anno = annotate_TUH(proc_subject[\"rawData\"], annoPath=self.EEG_dict[k][\"csvpath\"])\n                    raw_anno.plot()\n                    plt.title(\"Raw signal after simple preprocessing\")\n                    plt.show()\n\n\n            # Generate output windows for (X,y) as (array, label)\n            proc_subject[\"preprocessing_output\"] = slidingRawWindow(proc_subject,\n                                                                    t_max=proc_subject[\"rawData\"].times[-1],\n                                                                    tStep=proc_subject[\"tStep\"],\n                                                                    electrodeCLF=True)\n\n            for window in proc_subject[\"preprocessing_output\"].values():\n                Xwindows.append(window[0])\n                Ywindows.append(window[1])\n                #save info about which raw file and start time and end time this window is.\n                windowInfo.append(self.EEG_dict[k]['path'],window[2],window[3])\n\n        toc = time.time()\n        print(\"\\n~~~~~~~~~~~~~~~~~~~~\\n\"\n              \"it took %imin:%is to run electrode classifier preprocess-pipeline for %i patients\\n with window length [%.2fs] and t_step [%.2fs]\"\n              \"\\n~~~~~~~~~~~~~~~~~~~~\\n\" % (int((toc - tic) / 60), int((toc - tic) % 60), len(subjects_TUAR19),\n                                            tWindow, tStep))\n\n        Ywindows = oneHotEncoder(Ywindows, enumerate_labels=True, clfbin=True)\n\n        return Xwindows, Ywindows,windowInfo\n\n    def prep(self, tWindow=100, tStep=100 *.25,plot=False):\n        self.tWindow=tWindow\n        self.tStep=tStep\n        tic = time.time()\n        subjects_TUAR19 = defaultdict(dict)\n        Xwindows = []\n        Ywindows = []\n        for k in range(len(self.EEG_dict)):\n            subjects_TUAR19[k] = {'path': self.EEG_dict[k]['path']}\n\n            proc_subject = subjects_TUAR19[k]\n            proc_subject = self.readRawEdf(proc_subject, tWindow=tWindow, tStep=tStep,\n                                           read_raw_edf_param={'preload': True})\n            if k == 0 and plot:\n                #Plot the energy voltage potential against frequency.\n                #proc_subject[\"rawData\"].plot_psd(tmax=np.inf, fmax=128, average=True)\n\n                raw_anno = annotate_TUH(proc_subject[\"rawData\"],annoPath=self.EEG_dict[k][\"csvpath\"])\n                raw_anno.plot()\n                plt.show()\n\n            proc_subject[\"rawData\"] = TUH_rename_ch(proc_subject[\"rawData\"])\n            TUH_pick = ['Fp1', 'Fp2', 'F3', 'F4', 'C3', 'C4', 'P3', 'P4', 'O1', 'O2',\n                        'F7', 'F8', 'T3', 'T4', 'T5', 'T6', 'Cz']  # A1, A2 removed\n            proc_subject[\"rawData\"].pick_channels(ch_names=TUH_pick)\n            proc_subject[\"rawData\"].reorder_channels(TUH_pick)\n\n            if k == 0 and plot:\n                #Plot the energy voltage potential against frequency.\n                proc_subject[\"rawData\"].plot_psd(tmax=np.inf, fmax=128, average=True)\n\n                raw_anno = annotate_TUH(proc_subject[\"rawData\"],annoPath=self.EEG_dict[k][\"csvpath\"])\n                raw_anno.plot()\n                plt.show()\n\n            preprocessRaw(proc_subject[\"rawData\"], cap_setup=\"standard_1005\", lpfq=1, hpfq=40, notchfq=60,\n                     downSam=250)\n\n            if k == 0:\n\n                self.sfreq = proc_subject[\"rawData\"].info[\"sfreq\"]\n                self.ch_names = proc_subject[\"rawData\"].info[\"ch_names\"]\n                if plot:\n                    proc_subject[\"rawData\"].plot_psd(tmax=np.inf, fmax=125, average=True)\n\n                    raw_anno = annotate_TUH(proc_subject[\"rawData\"], annoPath=self.EEG_dict[k][\"csvpath\"])\n                    raw_anno.plot()\n                    plt.show()\n\n            # Generate output windows for (X,y) as (array, label)\n            proc_subject[\"preprocessing_output\"] = slidingRawWindow(proc_subject,\n                                                                    t_max=proc_subject[\"rawData\"].times[-1],\n                                                                    tStep=proc_subject[\"tStep\"])\n\n            for window in proc_subject[\"preprocessing_output\"].values():\n                Xwindows.append(window[0])\n                Ywindows.append(window[1])\n\n        toc = time.time()\n        print(\"\\n~~~~~~~~~~~~~~~~~~~~\\n\"\n              \"it took %imin:%is to run preprocess-pipeline for %i patients\\n with window length [%.2fs] and t_step [%.2fs]\"\n              \"\\n~~~~~~~~~~~~~~~~~~~~\\n\" % (int((toc - tic) / 60), int((toc - tic) % 60), len(subjects_TUAR19),\n                                            tWindow, tStep))\n\n        self.Xwindows = Xwindows\n        self.Ywindows = Ywindows\n\n    def specMaker(self):\n        Xwindows=self.Xwindows\n        Freq = self.sfreq\n        tWindow=self.tWindow\n        tStep=self.tStep\n        overlap=(tWindow-tStep)/tWindow #The amount of the window that overlaps with the next window.\n\n        for k in range(len(Xwindows)):\n            spectrogramMake(Xwindows[k], Freq,FFToverlap=overlap,tWindow=tWindow, show_chan_num=1,chan_names=self.ch_names)\n\n# renames TUH channels to conventional 10-20 system\ndef TUH_rename_ch(MNE_raw=False):\n    # MNE_raw\n    # mne.channels.rename_channels(MNE_raw.info, {\"PHOTIC-REF\": \"PROTIC\"})\n    for i in MNE_raw.info[\"ch_names\"]:\n        reSTR = r\"(?<=EEG )(\\S*)(?=-REF)\"  # working reSTR = r\"(?<=EEG )(.*)(?=-REF)\"\n        reLowC = ['FP1', 'FP2', 'FZ', 'CZ', 'PZ']\n\n        if re.search(reSTR, i) and re.search(reSTR, i).group() in reLowC:\n            lowC = i[0:5]+i[5].lower()+i[6:]\n            mne.channels.rename_channels(MNE_raw.info, {i: re.findall(reSTR, lowC)[0]})\n        elif i == \"PHOTIC-REF\":\n            mne.channels.rename_channels(MNE_raw.info, {i: \"PHOTIC\"})\n        elif re.search(reSTR, i):\n            mne.channels.rename_channels(MNE_raw.info, {i: re.findall(reSTR, i)[0]})\n        else:\n            continue\n            # print(i)\n    print(MNE_raw.info[\"ch_names\"])\n    return MNE_raw\n\ndef label_TUH(annoPath=False, window=[0, 0], header=None,channel=None):  # saveDir=os.getcwd(),\n    df = pd.read_csv(annoPath, sep=\",\", skiprows=6, header=header)\n    df.fillna('null', inplace=True)\n    within_con0 = (df[2] <= window[0]) & (window[0] <= df[3])\n    within_con1 = (df[2] <= window[1]) & (window[1] <= df[3])\n    if channel:\n        chan_names = df[1].to_numpy().tolist()\n        low_char = {'FP1': 'Fp1', 'FP2': 'Fp2', 'FZ': 'Fz', 'CZ': 'Cz', 'PZ': 'Pz'}\n        for i in range(len(chan_names)):\n            # remove numbers behind channel names:\n            chan_names[i] = [chan_names[i][:-3], chan_names[i][-2:]]\n\n            # Loop through all channel names in reverse order, so if something is removed it does not affect other index.\n            # Change certain channels to have smaller letters:\n            for k in range(len(chan_names[i]) - 1, -1, -1):\n                if chan_names[i][k] in low_char:\n                    chan_names[i][k] = low_char[chan_names[i][k]]\n        label_TUH = df[(df[2].between(window[0], window[1]) |\n                       df[3].between(window[0], window[1]) |\n                       (within_con0 & within_con1))\n                       & (np.sum(np.asarray(chan_names)==np.asarray(channel),axis=1).tolist())\n                        & ((df[4].to_numpy()=='elec')|\n                           (df[4].to_numpy()=='musc_elec')|\n                           (df[4].to_numpy()=='eyem_elec')|\n                           (df[4].to_numpy()=='shiv_elec')|\n                           (df[4].to_numpy()=='chew_elec'))]\n    else:\n        label_TUH = df[df[2].between(window[0], window[1]) |\n                   df[3].between(window[0], window[1]) |\n                   (within_con0 & within_con1)]\n    label_df = label_TUH.rename(columns={2: 't_start', 3: 't_end', 4: 'label', 5: 'confidence'})[\"label\"]  # Renamer headers i pandas dataen\n    return_list = label_df.to_numpy().tolist()  # Outputter kun listen af label navne i vinduet, fx [\"eyem\", \"null\"]\n    if return_list==[]:\n        return_list=['null']\n    elif channel:\n        return_list=['elec']\n    return return_list\n\n\ndef makeArrayWindow(MNE_raw=None, t0=0, tWindow=120):\n    # take a raw signal and make a window given time specifications. Outputs an array, because of raw.get_data().\n    chWindows = MNE_raw.get_data(start=int(t0), stop=int(t0 + tWindow), reject_by_annotation=None, picks=['eeg'])\n    return chWindows\n\n\ndef slidingRawWindow(EEG_series=None, t_max=0, tStep=1,electrodeCLF=False):\n    #If electrodeCLF is set to true, the function outputs a window per channel\n    # with labels assigned only for this channel.\n\n    # catch correct sample frequency and end sample\n    edf_fS = EEG_series[\"rawData\"].info[\"sfreq\"]\n    t_N = int(t_max * edf_fS)\n\n    # ensure window-overlaps progress in sample interger\n    if float(tStep * edf_fS) == float(int(tStep * edf_fS)):\n        t_overlap = int(tStep * edf_fS)\n    else:\n        t_overlap = int(tStep * edf_fS)\n        overlap_change = 100 - (t_overlap / edf_fS) * 100\n        print(\"\\n  tStep [%.3f], overlap does not equal an interger [%f] and have been rounded to %i\"\n              \"\\n  equaling to %.1f%% overlap or %.3fs time steps\\n\\n\"\n              % (tStep, tStep * edf_fS, t_overlap, overlap_change, t_overlap / edf_fS))\n\n    # initialize variables for segments\n    window_EEG = defaultdict(tuple)\n    window_width = int(EEG_series[\"tWindow\"] * edf_fS)\n    label_path = EEG_series['path'].split(\".edf\")[0] + \".csv\"\n\n    # segment all N-1 windows (by positive lookahead)\n    for i in range(0, t_N - window_width, t_overlap):\n        t_start = i / edf_fS\n        t_end = (i + window_width) / edf_fS\n        window_key = \"window_%.3fs_%.3fs\" % (t_start, t_end)\n        window_data = makeArrayWindow(EEG_series[\"rawData\"], t0=i, tWindow=window_width)  # , show_chan_num=0) #)\n        if electrodeCLF:\n            for i in range(len(window_data)):\n                chan=EEG_series['rawData'].info['ch_names'][i]\n                channel_label=label_TUH(annoPath=label_path, window=[t_start, t_end],channel=chan)\n                oneHotChan=(np.asarray(EEG_series['rawData'].info['ch_names'])==chan)*1\n                window_EEG[window_key+f\"{i}\"] = (np.concatenate((oneHotChan,window_data[i])), channel_label,t_start,t_end)\n        else:\n            window_label = label_TUH(annoPath=label_path, window=[t_start, t_end],channel=None)  # , saveDir=annoDir)\n            window_EEG[window_key] = (window_data, window_label)\n    # window_N segments (by negative lookahead)\n    if t_N % t_overlap != 0:\n        t_start = (t_N - window_width) / edf_fS\n        t_end = t_N / edf_fS\n        window_key = \"window_%.3fs_%.3fs\" % (t_start, t_end)\n        window_data = makeArrayWindow(EEG_series[\"rawData\"], t0=i, tWindow=window_width)\n        if electrodeCLF:\n            for i in range(len(window_data)):\n                chan=EEG_series['rawData'].info['ch_names'][i]\n                channel_label=label_TUH(annoPath=label_path, window=[t_start, t_end],channel=chan)\n                oneHotChan=(np.asarray(EEG_series['rawData'].info['ch_names'])==chan)*1\n                window_EEG[window_key+f\"{i}\"] = (np.concatenate((oneHotChan,window_data[i])), channel_label,t_start,t_end)\n        else:\n            window_label = label_TUH(annoPath=label_path, window=[t_start, t_end])  # , saveDir=annoDir)\n            window_EEG[window_key] = (window_data, window_label)\n    return window_EEG\n\ndef plotWindow(EEG_series,label=\"null\", t_max=0, t_step=1):\n    edf_fS = EEG_series[\"rawData\"].info[\"sfreq\"]\n    t_N = int(t_max * edf_fS)\n    window_width = int(EEG_series[\"tWindow\"] * edf_fS)\n    label_path = EEG_series['path'].split(\".edf\")[0] + \".csv\"\n\n    for i in range(0, t_N - window_width, t_step):\n        t_start = i / edf_fS\n        t_end = (i + window_width) / edf_fS\n        window_label = label_TUH(annoPath=label_path, window=[t_start, t_end])\n        if len(window_label)==1 & window_label[0]==label:\n            return EEG_series[\"rawData\"].plot(t_start=t_start, t_end=t_end)\n    return None\n\n# The function \"annotate_TUH()\" takes a raw signal and a path for a csv file with annotations/labels in it.\n# The annotations are read and added to the raw signal. The function is mainly made for the purpose of making\n# plots with the artifacts showing.\ndef annotate_TUH(raw,annoPath=False, header=None):\n    df = pd.read_csv(annoPath, sep=\",\", skiprows=6, header=header)\n    t_start=df[2].to_numpy()\n    dura=df[3].to_numpy()-t_start\n    labels=df[4].to_numpy().tolist()\n    chan_names=df[1].to_numpy().tolist()\n    t_start=t_start.tolist()\n    dura=dura.tolist()\n\n    delete=[]\n    low_char={'FP1':'Fp1', 'FP2':'Fp2', 'FZ':'Fz', 'CZ':'Cz', 'PZ':'Pz'}\n    for i in range(len(chan_names)):\n        #remove numbers behind channel names:\n        chan_names[i]=[chan_names[i][:-3],chan_names[i][-2:]]\n\n        # Loop through all channel names in reverse order, so if something is removed it does not affect other index.\n        # Change certain channels to have smaller letters:\n        for k in range(len(chan_names[i])-1,-1,-1):\n            if chan_names[i][k] in low_char:\n                chan_names[i][k]=low_char[chan_names[i][k]]\n\n            # If channel names are not in the raw info their are removed from an annotation:\n            if chan_names[i][k] not in raw.ch_names:\n                chan_names[i].remove(chan_names[i][k])\n\n        # If no channel names are left for an annotation its index is saved for later removal entirely:\n        # (It could potentially just be annotated for the whole signal)\n        if not chan_names[i]:\n            delete.append(i)\n\n\n    #removes every annotation that cannot be handled backwards:\n    for ele in sorted(delete,reverse=True):\n        print(f\"Annotation {labels[ele]} on non-existing channel {chan_names[ele]} removed from annotations.\")\n        del t_start[ele], dura[ele],labels[ele],chan_names[ele]\n\n    anno=mne.Annotations(onset=t_start,\n                            duration=dura,\n                              description=labels,\n                                ch_names=chan_names)\n\n    raw_anno=raw.set_annotations(anno)\n    return raw_anno\n\ndef spectrogramMake(MNE_window=None, freq = None, tWindow=100, crop_fq=45, FFToverlap=None, show_chan_num=None,chan_names=None):\n    try:\n        edfFs = freq\n        chWindows = MNE_window\n\n        if FFToverlap is None:\n            specOption = {\"x\": chWindows, \"fs\": edfFs, \"mode\": \"psd\"}\n        else:\n            window = signal.get_window(window=('tukey', 0.25), Nx=int(tWindow))  # TODO: error in 'Nx' & 'noverlap' proportions\n            specOption = {\"x\": chWindows, \"fs\": edfFs, \"window\": window, \"noverlap\": int(tWindow*FFToverlap), \"mode\": \"psd\"}\n\n        fAx, tAx, Sxx = signal.spectrogram(**specOption)\n        normSxx = stats.zscore(np.log(Sxx[:, fAx <= crop_fq, :] + 2**-52)) #np.finfo(float).eps))\n        if isinstance(show_chan_num, int):\n            plot_spec = plotSpec(ch_names=chan_names, chan=show_chan_num,\n                                 fAx=fAx[fAx <= crop_fq], tAx=tAx, Sxx=normSxx)\n            plot_spec.show()\n    except:\n        print(\"pause here\")\n        # fTemp, tTemp, SxxTemp = signal.spectrogram(chWindows[0], fs=edfFs)\n        # plt.pcolormesh(tTemp, fTemp, np.log(SxxTemp))\n        # plt.ylabel('Frequency [Hz]')\n        # plt.xlabel('Time [sec]')\n        # plt.title(\"channel spectrogram: \"+MNE_raw.ch_names[0])\n        # plt.ylim(0,45)\n        # plt.show()\n\n    return torch.tensor(normSxx.astype(np.float16)) # for np delete torch.tensor\n\ndef plotSpec(ch_names=False, chan=False, fAx=False, tAx=False, Sxx=False):\n    # fTemp, tTemp, SxxTemp = signal.spectrogram(chWindows[0], fs=edfFs)\n    # normSxx = stats.zscore(np.log(Sxx[:, fAx <= cropFq, :] + np.finfo(float).eps))\n    plt.pcolormesh(tAx, fAx, Sxx[chan, :, :])\n    plt.ylabel('Frequency [Hz]')\n    plt.xlabel('Time [sec]')\n    plt.title(\"channel spectrogram: \" + ch_names[chan])\n\n    return plt\n\ndef solveLabelChannelRelation(annoPath, header = None):\n    df = pd.read_csv(annoPath, sep=\",\", skiprows=6, header=header)\n\n    # Split pairs into single channels\n    #channel_pairs=df[1].to_numpy().tolist()\n    #channel_pairs=[n.split('-') for n in channel_pairs]\n    #channel_unique=list(set([n for n in channel_pairs]))\n    #Creating data frame:\n    anno_df=pd.DataFrame(columns=['channel','t_start','t_end','label'])\n\n    #checking every entry in label data:\n    for i in tqdm(range(len(df))):\n        chan1, chan2=df[1][i].split('-')\n        # Only check row against rows further down:\n        temp = df[i+1:]\n        # Only rows with same label:\n        temp = temp[temp[4] == df[4][i]]\n\n        # Only overlap in time:\n        temp_time = temp[((df[2][i]<=temp[2]) & (temp[2]<=df[3][i])) |\n                         ((df[2][i]<=temp[3]) & (temp[3]<=df[3][i])) |\n                         ((temp[2]<df[2][i]) & (df[3][i]<temp[3]))]\n\n        for k in temp_time.index:\n            #check if first channel is a match with one in the new channel pair:\n            channel = None\n            if chan1 in temp_time[1][k].split('-'):\n                channel = chan1\n            elif chan2 in temp_time[1][k].split('-'):\n                channel = chan2\n            if channel in [chan1, chan2]:\n                t_start = max(df[2][i], temp_time[2][k])\n                t_end = min(df[3][i], temp_time[3][k])\n\n                anno_new = pd.DataFrame({'channel': [channel], 't_start': [t_start],\n                                         't_end': [t_end], 'label': [df[4][i]]})\n\n                #if ((anno_new['channel'] == anno_df['channel']) & (anno_new['t_start'] == anno_df['t_start'])\n                #    & (anno_new['t_end'] == anno_df['t_end']) & (anno_new['label'] == anno_df['label'])).any():\n                #    anno_df.append(anno_new)\n\n                duplicates=anno_df[ ([df[4][i]]==anno_df['label']) &\n                         (chan1==anno_df['channel'])  &\n                        (((t_start<=anno_df['t_start']) & (anno_df['t_start']<=t_end)) |\n                         ((t_start<=anno_df['t_end']) & (anno_df['t_end']<=t_end)) |\n                         ((anno_df['t_start']<t_start) & (t_end<anno_df['t_end'])))]\n\n                if duplicates:\n                    new_t_start = min(duplicates['t_start'],t_start)\n                    new_t_end = max(duplicates['t_end'], t_start)\n\n                    anno_new = pd.DataFrame({'channel': [chan1], 't_start': [new_t_start],\n                                             't_end': [new_t_end], 'label': [df[4][i]]})\n                    anno_df.append(anno_new)\n\n                    #delete overlapping rows from behind so the indexes are not confused:\n                    for n in len(duplicates):\n                        index=duplicates.index[-n]\n                        anno_df.drop(index=index)\n\n                # if no duplicates/overlaps found, then just save annotation for channel:\n                else:\n                    anno_new = pd.DataFrame({'channel': [chan1], 't_start': [t_start],\n                                             't_end': [t_end], 'label': [df[4][i]]})\n                    anno_df.append(anno_new)\n\n            # check if second channel is a match with one in the new channel pair:\n            if chan2 in channel_pairs[k]:\n                pass\n                # Starts and ends at same time:\n                if df[2][i] == df[2][k] and df[3][i] == df[3][k]:\n                    pass\n                # elif\n            else:\n                pass\n                #print(\"No checks passed \\n\"\n                #      \"Channel 1: {} ({}-{} s) \\n\"\n                #      \"Channel 2: {} ({}-{} s)\".format(chan1, df[2][i], df[3][i], chan2, df[2][k], df[3][k]))\n\n    return anno_df\n\n\n\n\ndef labelChannels(annoPath, header = None):\n    df = pd.read_csv(annoPath, sep=\",\", skiprows=6, header=header)\n\n    # Split pairs into single channels\n    channel_pairs = df[1].to_numpy().tolist()\n    channel_pairs = [n.split('-') for n in channel_pairs]\n\n    # Creating data frame:\n    anno_df = pd.DataFrame(columns=['channel', 't_start', 't_end', 'label'])\n\n    anno_dict = defaultdict(lambda: (0, 0))\n\n    # Checking every entry in label data:\n    for i in tqdm(range(len(channel_pairs))):\n        # Check if label is the same in the two rows, eg. 'elec'=='elec':\n        # Create two variables, one for each channel in the pair:\n        chan1, chan2 = channel_pairs[i]\n        for k in range(i+1,len(channel_pairs)):\n            #Check if label is the same in the two rows, eg. 'elec'=='elec':\n            if df[4][i] == df[4][k]:\n                #Add both time frames to anno_dict\n               anno_dict[chan1] = (df[2][i], df[3][i])\n               anno_dict[chan2] = (df[2][i], df[3][i])\n\n\n\nif __name__ == \"__main__\":\n    path = \"../TUH_data_sample/131/00013103/s001_2015_09_30/00013103_s001_t000.csv\"\n\n    solveLabelChannelRelation(annoPath=path)\n\n    #labelChannels(annoPath=path)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pipeline/loadFunctions.py b/pipeline/loadFunctions.py
--- a/pipeline/loadFunctions.py	(revision 4713985bc4fa624833d053ecc7a7ff522fffc56b)
+++ b/pipeline/loadFunctions.py	(date 1651073527777)
@@ -512,13 +512,6 @@
                                              't_end': [t_end], 'label': [df[4][i]]})
                     anno_df.append(anno_new)
 
-            # check if second channel is a match with one in the new channel pair:
-            if chan2 in channel_pairs[k]:
-                pass
-                # Starts and ends at same time:
-                if df[2][i] == df[2][k] and df[3][i] == df[3][k]:
-                    pass
-                # elif
             else:
                 pass
                 #print("No checks passed \n"
